---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on:
  - 01-01
files_modified:
  - cotizador-template/cotizador-template.html
autonomous: true
requirements:
  - FOUND-02
must_haves:
  truths:
    - "assignHardware('modulo', {w:800, h:2000, d:500}, {cajones:4, corrTier:'corr_eco', doors:false}) returns corr_eco x4 and jaladera x4"
    - "assignHardware('colgador', dims, opts) returns tubo x1 and soporte x2"
    - "assignHardware('zapatero', dims, opts) returns corr_eco x6"
    - "assignHardware('cajonBase', dims, opts) returns corr_oculta x N (matching drawer count)"
    - "assignHardware('puerta', dims, opts) returns bisagra and base_clip with count from getBisagraCount()"
    - "calc() calls assignHardware() and the quotation totals match pre-refactor output"
  artifacts:
    - path: "cotizador-template/cotizador-template.html"
      provides: "assignHardware() generic function"
      contains: "function assignHardware"
  key_links:
    - from: "assignHardware()"
      to: "HW_DEFAULTS and getBisagraCount()"
      via: "hardware key lookup and bisagra rule application"
      pattern: "function assignHardware\\(moduleType"
    - from: "calc()"
      to: "assignHardware()"
      via: "delegation call replacing inline autoHW.push blocks"
      pattern: "assignHardware\\(m\\.type"
---

<objective>
Create the generic `assignHardware(moduleType, dimensions, options)` function that auto-assigns hardware items based on module type and dimensions, then wire it into `calc()` replacing the temporary hwHints from Plan 01.

Purpose: Every future module type will call this single function for hardware assignment instead of scattering autoHW.push() calls throughout the codebase. This completes the foundation layer — both piece calculation and hardware assignment are now generic, reusable functions.

Output: A new `assignHardware()` function in the calculation section, with all existing hardware rules extracted from `calc()` and documented with AUDIT comments.
</objective>

<execution_context>
@C:/Users/Steven PC/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Steven PC/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/CONVENTIONS.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@cotizador-template/cotizador-template.html (lines 2951-3050: CONFIG, lines 3032-3044: hardware.autoAssignRules, lines 3053-3066: getBisagraCount, lines 3240-3295: HW_DEFAULTS)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create assignHardware() function with all module hardware rules</name>
  <files>cotizador-template/cotizador-template.html</files>
  <action>
Create a new function `assignHardware(moduleType, dimensions, options)` in the calculation section, placed right after `calculateParts()` and before `calc()`.

**Function signature:**
```javascript
function assignHardware(moduleType, dimensions, options) {
    // moduleType: string matching MODS keys
    // dimensions: { w: mm, h: mm, d: mm }
    // options: { cajones, corrTier, doors, tipon, doorCount, doorMaterial, materialType, shelves, heightCm, marco }
    // Returns: array of { key: string (HW_DEFAULTS key), q: number }
}
```

**CRITICAL: ES5 only.** var, function(){}, no let/const/arrow/template literals.

**Extract these hardware rules from the current calc() function, documenting each with AUDIT comments:**

1. **modulo** (closet drawer module):
   - If cajones > 0: corredera (key from corrTier, default 'corr_eco') x cajones
   - If cajones > 0 AND no doors: jaladera x cajones
   - AUDIT: Default slide type is economica; user can upgrade via corrTier property

2. **colgador** (hanging bar):
   - tubo x 1
   - soporte x 2
   - AUDIT: One tube per module, two brackets (left + right support)

3. **zapatero** (shoe rack):
   - corr_eco x 6
   - AUDIT: 6 pull-out shoe trays, each needs one pair of slides

4. **esquinero** (L-shape corner):
   - tubo x 1
   - soporte x 2
   - AUDIT: Corner module gets a hanging bar like colgador

5. **cajonBase** (cocina drawer base):
   - corr_oculta x cajones
   - AUDIT: Cocina base drawers use premium soft-close concealed slides

6. **puerta** (door):
   - bisagra x getBisagraCount(heightCm, materialType)
   - base_clip x same count
   - AUDIT: Hinge count driven by CONFIG rules based on door height and material weight

7. **All other module types** (entrepa, torreLateral, panelTV, moduloCentral, lateralAbierto, alacenaAlta, gabineteBase, despensa, espacioCampana, esquineroGiratorio):
   - Return empty array (no auto-assigned hardware for these types currently)
   - AUDIT: These types get hardware only through doors (handled separately in calc) or manual assignment

**Do NOT include door-related hardware** (bisagras for doors, tipon, jaladera for doors) — those are handled by the cross-cutting door block in calc() and should stay there.

**Return format:** Array of `{ key, q }` objects.
  </action>
  <verify>
1. Function exists in the calculation section after calculateParts()
2. ES5 syntax only (no let/const/arrow functions)
3. All 5 closet hardware rules documented with AUDIT comments
4. Returns array of { key, q } objects
5. Does not duplicate door hardware logic (that stays in calc)
  </verify>
  <done>
`assignHardware(moduleType, dimensions, options)` function exists, returns correct hardware arrays for all module types that have auto-assigned hardware, with AUDIT comments on every rule.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire assignHardware() into calc() and remove hwHints workaround</name>
  <files>cotizador-template/cotizador-template.html</files>
  <action>
Refactor calc() to use assignHardware() instead of the temporary hwHints from Plan 01's calculateParts() return.

**Changes to calc():**

1. After the `calculateParts()` call and piece stamping, add:
```javascript
var modHW = assignHardware(m.type, { w: w, h: h, d: d }, {
    cajones: typeof m.cajones === 'number' ? m.cajones : undefined,
    corrTier: m.corrTier,
    doors: m.doors,
    tipon: m.tipon,
    shelves: m.shelves,
    heightCm: m.height || P.defaultHeight || 200,
    materialType: m.materialType,
    marco: m.marco
});
modHW.forEach(function(hw) {
    hw.modId = m.id;
    autoHW.push(hw);
});
```

2. **Remove the hwHints workaround** from Plan 01. If calculateParts() returns `{ pieces, hwHints }`, change it back to returning just the pieces array. Remove any hwHints processing from calc(). The clean separation is: calculateParts() handles ONLY pieces, assignHardware() handles ONLY hardware.

3. **Keep the door hardware block** in calc() (the `if (m.doors || qm === 'solo_puertas')` block at ~lines 5098-5146) unchanged — door bisagras, tipon, jaladeras are cross-cutting and stay in calc().

4. **Keep the puerta module type's hardware assignment** — when m.type === 'puerta', assignHardware() returns bisagra and base_clip. This is DIFFERENT from the door hardware block (which handles doors on any module type). The puerta type IS the door itself as a product.

**Verification approach:** Same as Plan 01 Task 2 — open the app, create a closet project, add modules, check Step 3 despiece and pricing. Also verify:
- A modulo with doors shows bisagras (from the door block in calc) + correderas (from assignHardware)
- A colgador without doors shows tubo + soporte (from assignHardware) but no bisagras
- A colgador with doors shows tubo + soporte + bisagras + jaladeras
  </action>
  <verify>
1. Open the HTML file in a browser
2. Create a closet project, add: modulo 80cm with 4 cajones and doors ON, colgador 90cm with doors OFF, zapatero 90cm, entrepa 60cm with doors ON
3. Navigate to Step 3 — verify pieces list is correct
4. Navigate to Step 4 — verify hardware shows: corr_eco (4 for modulo), bisagras (for modulo doors + entrepa doors), tubo (1 for colgador), soporte (2 for colgador), corr_eco (6 for zapatero), jaladeras (for entrepa doors)
5. Verify total pricing is non-zero and reasonable
6. Check browser console for zero JavaScript errors
7. Verify calculateParts() returns only pieces array (no hwHints)
  </verify>
  <done>
calc() delegates hardware assignment to assignHardware() for module-specific hardware. calculateParts() returns only pieces (clean separation). The door hardware block remains in calc(). A closet quotation with mixed modules produces the correct hardware list and pricing with zero console errors.
  </done>
</task>

</tasks>

<verification>
1. `assignHardware` function exists and is callable
2. `calc()` calls both `calculateParts()` and `assignHardware()` with clean separation
3. calculateParts() returns only pieces, assignHardware() returns only hardware hints
4. Closet quotation with doors ON/OFF produces correct hardware assignments
5. No regressions — pricing matches pre-refactor output
</verification>

<success_criteria>
- `assignHardware('modulo', dims, {cajones:4, corrTier:'corr_eco', doors:false})` returns `[{key:'corr_eco', q:4}, {key:'jaladera', q:4}]`
- `assignHardware('colgador', dims, {})` returns `[{key:'tubo', q:1}, {key:'soporte', q:2}]`
- calc() is cleanly factored: calculateParts() for pieces, assignHardware() for hardware, door block for cross-cutting door hardware
- The app loads, quotation flow works end-to-end, no JavaScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
