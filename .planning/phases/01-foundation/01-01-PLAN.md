---
phase: 01-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - cotizador-template/cotizador-template.html
autonomous: true
requirements:
  - FOUND-01
  - FOUND-03
must_haves:
  truths:
    - "calculateParts('modulo', {w:800, h:2000, d:500}, {thickness:16}) returns the same pieces as the current inline calc() logic for a closet modulo"
    - "calculateParts('colgador', dims, mats) returns laterales, techo/piso, entrepaño, and fondo matching current inline logic"
    - "calculateParts('zapatero', dims, mats) returns 6 charolas and a fondo matching current logic"
    - "calculateParts('esquinero', dims, mats) returns Lateral A, Lateral B, Diagonal, Techo/Piso, Entrepaño matching current logic"
    - "calculateParts('entrepa', dims, mats) returns laterales, techo/piso, N entrepaños, and fondo matching current logic"
    - "Every dimension formula for closet modules is documented with inline comments explaining the subtraction constants (e.g., w-32 = width minus 2x16mm panel thickness)"
  artifacts:
    - path: "cotizador-template/cotizador-template.html"
      provides: "calculateParts() generic function and closet audit comments"
      contains: "function calculateParts"
  key_links:
    - from: "calculateParts()"
      to: "MODS constant and CONFIG"
      via: "moduleType string lookup and thickness from materials param"
      pattern: "function calculateParts\\(moduleType"
---

<objective>
Create the generic `calculateParts(moduleType, dimensions, materials)` function by extracting and auditing the piece-generation logic currently inline in `calc()`.

Purpose: Every future module type (cocina, baño, TV, puerta) will call this single function instead of duplicating piece-generation logic. Auditing the closet formulas now documents the reusable dimension patterns (panel subtraction, drawer sizing, etc.) that all module types share.

Output: A new `calculateParts()` function placed in the calculation section of the IIFE, with closet module types (modulo, colgador, zapatero, esquinero, entrepa) fully supported and documented with inline comments explaining each formula.
</objective>

<execution_context>
@C:/Users/Steven PC/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Steven PC/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/CONVENTIONS.md
@.planning/codebase/ARCHITECTURE.md
@cotizador-template/cotizador-template.html (lines 2951-3050: CONFIG, lines 3146-3233: MODS, lines 4610-5096: calc() piece generation)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create calculateParts() with audited closet module formulas</name>
  <files>cotizador-template/cotizador-template.html</files>
  <action>
Create a new function `calculateParts(moduleType, dimensions, materials)` in the calculation section of the IIFE, BEFORE the existing `calc()` function (insert around line 4608, after `calcLedBOM()` and before the `calc()` comment block).

**Function signature:**
```javascript
function calculateParts(moduleType, dimensions, materials) {
    // moduleType: string matching MODS keys (e.g., 'modulo', 'colgador', 'zapatero', 'esquinero', 'entrepa')
    // dimensions: { w: mm, h: mm, d: mm, w2: mm (optional, for esquinero) }
    // materials: { thickness: number (16 or 25), cajones: number, shelves: number, quoteMode: string, corrTier: string }
    // Returns: array of piece objects { n, q, w, h, t, c, z }
```

**CRITICAL: Use ES5 only** — `var`, `function(){}`, string concatenation with `+`. No let/const/arrow/template literals.

**Extract these closet module types from the current `calc()` function (lines 4624-4955), adding audit comments to each formula:**

1. **modulo** (closet drawer module, line 4624-4735):
   - Lateral: q=2, w=d, h=h (full-depth side panels)
   - Techo/Piso: q=2, w=w-32, h=d (32 = 2 x 16mm panel thickness; adjust comment: w - 2*TK)
   - Fondo: q=1, w=w-2*TK, h=h-2*TK (back panel inset by panel thickness on all sides)
   - If cajones > 0: Frente cajon (q=caj, w=w-6, h=ch-6, c=4 edges, z='f'), Costado cajon (q=caj*2, w=d-50, h=ch-80), Int. cajon (q=caj*2, w=w-100, h=ch-80), Fondo cajon (q=caj, w=w-100, h=d-50)
   - If cajones == 0: Entrepano (q=shelves||3, w=w-32, h=d)
   - ch = Math.floor((h-100)/caj) — drawer front height = usable height (minus 100mm for structure) divided by drawer count
   - Document: 6mm gap on drawer fronts, 50mm clearance on drawer sides for slide mechanism, 80mm clearance on drawer height for slide, 100mm deduction on drawer interior width for slide + structure

2. **colgador** (hanging bar module, line 4736-4790):
   - Lateral: q=2, w=d, h=h
   - Techo/Piso: q=2, w=w-32, h=d (w - 2*TK)
   - Entrepaño: q=1, w=w-32, h=d (single shelf, same width deduction)
   - Fondo: q=1, w=w-2*TK, h=h-2*TK

3. **zapatero** (shoe rack, line 4791-4840):
   - Lateral: q=2, w=d, h=h
   - Techo/Piso: q=2, w=w-32, h=d
   - Charola: q=6, w=w-100, h=d-100 (pull-out trays, 100mm inset for slide mechanism)
   - Fondo: q=1, w=w-2*TK, h=h-2*TK

4. **esquinero** (L-shape corner, line 4841-4908):
   - Lateral A: q=1, w=w, h=h
   - Lateral B: q=1, w=w2, h=h (second dimension for L-shape)
   - Diagonal: q=1, w=Math.round(Math.sqrt(w*w+w2*w2)*0.5), h=h, c=2, z='f' (hypotenuse face panel)
   - Techo/Piso: q=2, w=w-2*TK, h=w2-2*TK
   - Entrepaño: q=1, w=w-2*TK, h=w2-2*TK

5. **entrepa** (shelf unit, line 4909-4954):
   - Lateral: q=2, w=d, h=h
   - Techo/Piso: q=2, w=w-32, h=d
   - Entrepaño: q=shelves||5, w=w-32, h=d
   - Fondo: q=1, w=w-2*TK, h=h-2*TK

**Also include the existing non-closet module types** so calc() can delegate ALL piece generation. Copy them as-is with minimal audit comments:
- torreLateral, panelTV, moduloCentral, lateralAbierto (TV types)
- alacenaAlta, gabineteBase, cajonBase, despensa, espacioCampana, esquineroGiratorio (Cocina types)
- puerta

The function should NOT handle door pieces (those are cross-cutting and will stay in calc()). The function should NOT handle hardware — that will be Plan 02.

**Return format:** Array of piece objects `{ n, q, w, h, t, c, z }` (no mid/mn/mw — those are module-context fields that calc() will add).

**Audit comments format:** Use `// AUDIT:` prefix for each formula explanation:
```javascript
// AUDIT: Lateral full depth, full height — no deductions (outer structural panels)
// AUDIT: Techo/Piso deduct 2x panel thickness from width — w - 2*TK (fits between laterales)
// AUDIT: 6mm gap on drawer fronts for alignment tolerance
```
  </action>
  <verify>
Open the HTML file in a text editor and confirm:
1. `calculateParts` function exists before `calc()`
2. Function uses ES5 syntax only (search for `=>`, `let `, `const ` — should find none in the new function)
3. Each closet module type has `// AUDIT:` comments explaining dimension formulas
4. Function returns an array of piece objects with `{ n, q, w, h, t, c, z }` structure
5. All 13 module types from the original calc() are covered (modulo, colgador, zapatero, esquinero, entrepa, torreLateral, panelTV, moduloCentral, lateralAbierto, alacenaAlta, gabineteBase, cajonBase, despensa, espacioCampana, esquineroGiratorio, puerta) — 16 total module types
  </verify>
  <done>
`calculateParts(moduleType, dimensions, materials)` function exists in the calculation section, returns correct piece arrays for all existing module types, and every closet dimension formula has an AUDIT comment documenting the subtraction constants and their physical meaning.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire calculateParts() into calc() replacing inline piece generation</name>
  <files>cotizador-template/cotizador-template.html</files>
  <action>
Refactor the `calc()` function to delegate piece generation to `calculateParts()` instead of having inline if/else chains.

**Replace the entire module-type if/else chain** (from `if (m.type === 'modulo')` through the closing of the puerta block, approximately lines 4624-5095) with a call to `calculateParts()`:

```javascript
var rawPieces = calculateParts(m.type, {
    w: w, h: h, d: d,
    w2: m.width2 ? m.width2 * 10 : undefined
}, {
    thickness: TK,
    cajones: typeof m.cajones === 'number' ? m.cajones : undefined,
    shelves: m.shelves,
    quoteMode: qm,
    corrTier: m.corrTier,
    marco: m.marco,
    materialType: m.materialType
});
// Stamp module context onto each piece
rawPieces.forEach(function(p) {
    p.mid = m.id;
    p.mn = m.name;
    p.mw = m.width;
    pieces.push(p);
});
```

**IMPORTANT:** The door piece generation block (lines ~5098-5146, starting with `if (m.doors || qm === 'solo_puertas')`) must REMAIN in `calc()` — do NOT move it to `calculateParts()`. Doors are cross-cutting across all module types.

**IMPORTANT:** The hardware autoHW pushes that are INSIDE the module-type blocks in the original calc() (e.g., corr_eco for zapatero, tubo/soporte for colgador, corr_oculta for cajonBase) should be removed from calc() and NOT added to calculateParts(). They will be handled by assignHardware() in Plan 02. For NOW, to keep the app working until Plan 02, add a temporary `_hw` property to the returned piece objects or create a separate temporary block that replicates the hardware assignments. The simplest approach: have `calculateParts()` also return hardware hints as a second structure. Change the return to `{ pieces: [...], hwHints: [...] }` where hwHints are `{ key, q }` objects. Then in calc(), after calling calculateParts, push the hwHints into autoHW.

**Verification approach:** After this refactor, open `cotizador-template.html` in a browser, create a new closet project, add one of each closet module type (modulo with 4 drawers, colgador, zapatero, esquinero, entrepa with 5 shelves), navigate to Step 3, and verify the despiece (pieces list) shows the same pieces as before the refactor. The total sheet count and pricing should be identical.

**Do NOT change** the area calculation, material cost, hardware consolidation, margins, or any other part of calc() — only the piece generation delegation.
  </action>
  <verify>
1. Open the HTML file in a browser
2. Create a new closet project with default settings (16mm thickness)
3. Add modules: modulo (80cm, 4 cajones), colgador (90cm), zapatero (90cm), entrepa (60cm, 5 shelves)
4. Navigate to Step 3 (cost breakdown)
5. Verify pieces list shows all expected pieces for each module
6. Verify total sheets and pricing are non-zero and reasonable
7. Check browser console for zero JavaScript errors
  </verify>
  <done>
The `calc()` function delegates all piece generation to `calculateParts()` via `{ pieces, hwHints }` return. The closet quotation flow (add modules, view despiece, view costs) produces identical results to the pre-refactor state. No JavaScript errors in the console.
  </done>
</task>

</tasks>

<verification>
1. `calculateParts` function exists and is callable
2. `calc()` calls `calculateParts()` instead of inline piece generation
3. Closet quotation produces correct pieces and pricing
4. All closet dimension formulas have AUDIT comments
5. No regressions — existing module types still work
</verification>

<success_criteria>
- `calculateParts('modulo', {w:800, h:2000, d:500}, {thickness:16})` returns the correct 7-piece array for a 4-drawer closet module
- `calculateParts('colgador', {w:900, h:2000, d:600}, {thickness:16})` returns 4 pieces (2 laterales, 2 techo/piso, 1 entrepaño, 1 fondo)
- Every closet module dimension formula has an `// AUDIT:` comment
- `calc()` function is shorter by ~400 lines (piece generation delegated out)
- The app loads and runs without JavaScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-01-SUMMARY.md`
</output>
