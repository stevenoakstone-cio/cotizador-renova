---
phase: 04-cocina-extras-ui-output
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - cotizador-template/cotizador-template.html
autonomous: true
requirements: [CEXT-01, CEXT-02, CEXT-03, CEXT-04, CUI-01, CUI-02]

must_haves:
  truths:
    - "Selecting Cocina in Step 1 filters Step 2 module picker to only cocina modules"
    - "Module picker groups cocina modules by category: Bajos, Alacenas, Torres, Extras"
    - "User can add zoclo, vista lateral, panel de relleno, and cubierta as extras modules"
    - "Cubierta pricing uses m2-based formula for postformado/cuarzo/granito"
  artifacts:
    - path: "cotizador-template/cotizador-template.html"
      provides: "4 new MODS entries for extras, MODS.*.forType field, step2() filtering + category grouping"
      contains: "forType"
  key_links:
    - from: "MODS entries"
      to: "step2() module buttons"
      via: "forType filter matching P.type"
      pattern: "forType.*cocina"
    - from: "cubierta MODS entry"
      to: "calc() extras section"
      via: "m2 pricing in calc()"
      pattern: "cubierta"
---

<objective>
Add 4 cocina extras module types (zoclo, vista lateral, panel relleno, cubierta) to MODS + calculateParts(), add `forType` category field to all MODS entries, and implement module filtering + category grouping in step2().

Purpose: Users selecting "Cocina" see only cocina modules organized by category; extras modules enable quoting finishing pieces.
Output: Modified cotizador-template.html with filtering, grouping, and 4 new extras types.
</objective>

<execution_context>
@C:/Users/Steven PC/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Steven PC/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-cocina-bajos/02-01-SUMMARY.md
@.planning/phases/03-cocina-altos-torres/03-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add forType field to all MODS entries, add 4 extras MODS + calculateParts(), and add cubierta pricing to CONFIG</name>
  <files>cotizador-template/cotizador-template.html</files>
  <action>
1. Add a `forType` field to every MODS entry indicating which project type(s) can use it. Use an array of type IDs. Add a `cat` field for display category grouping.

Existing closet modules (modulo, colgador, zapatero, esquinero, entrepa): `forType: ['closet']`
Existing TV modules (torreLateral, lateralAbierto, etc.): `forType: ['tv']` (check which ones exist for TV)
Existing puerta: `forType: ['puerta']`

Cocina bajos (bajoEstandar, fregadero, cajonera, esquineroCiego, hornoBase): `forType: ['cocina'], cat: 'Bajos'`
Cocina alacenas (alacenaEstandar, alacenaAventos, alacenaSobreCampana): `forType: ['cocina'], cat: 'Alacenas'`
Cocina torres (torreHornos, torreDespensa): `forType: ['cocina'], cat: 'Torres'`

2. Add 4 new MODS entries for cocina extras with `forType: ['cocina'], cat: 'Extras'`:

```javascript
zoclo: {
    n: 'Zoclo',
    w: [30, 40, 50, 60, 75, 80, 90, 100],
    d: 'Vista frontal inferior | melamina o aluminio',
    forType: ['cocina'],
    cat: 'Extras',
    custom: 1
},
vistaLateral: {
    n: 'Vista Lateral',
    w: [58, 60],
    d: 'Panel lateral visible | material premium',
    forType: ['cocina'],
    cat: 'Extras'
},
panelRelleno: {
    n: 'Panel de Relleno',
    w: [5, 10, 15, 20, 30, 50],
    d: 'Tira entre modulo y pared | 5-100mm',
    forType: ['cocina'],
    cat: 'Extras',
    custom: 1
},
cubierta: {
    n: 'Cubierta',
    w: [60, 90, 120, 150, 180, 240, 300],
    d: 'Superficie superior m2 | postformado/cuarzo/granito',
    forType: ['cocina'],
    cat: 'Extras',
    custom: 1
}
```

3. Add cubierta pricing to CONFIG.pricing (after existing pricing properties):
```javascript
// Cubierta pricing per m2 (MXN)
if (!CONFIG.pricing.cubiertaPrices) {
    CONFIG.pricing.cubiertaPrices = {
        postformado: 2500,
        cuarzo: 8500,
        granito: 6500
    };
}
```

4. Add calculateParts() blocks for the 4 extras types. These are simple — mostly single-piece modules:

**zoclo:** Single piece. Width = module width, height = 150mm (standard zoclo height), t = TK. Zone = 'f' (visible frente material).
```javascript
} else if (moduleType === 'zoclo') {
    // AUDIT: Zoclo — linear piece, w=module width, h=150mm standard, frente material
    pieces.push({ n: 'Zoclo', qty: 1, w: w, h: 150, t: TK, z: 'f' });
```

**vistaLateral:** Single piece. Width = depth of bajo (580mm standard, but use `d` parameter), height = casco height (720mm standard, but use `h` parameter). Zone = 'f' (premium material).
```javascript
} else if (moduleType === 'vistaLateral') {
    // AUDIT: Vista lateral — panel expuesto, profundidad x alto casco, frente material
    pieces.push({ n: 'Vista Lateral', qty: 1, w: d, h: h, t: TK, z: 'f' });
```

**panelRelleno:** Single piece. Width = module width (the gap width), height = h parameter. Zone = 'f'.
```javascript
} else if (moduleType === 'panelRelleno') {
    // AUDIT: Panel relleno — tira entre modulo y pared, ancho = gap, alto = casco
    pieces.push({ n: 'Panel Relleno', qty: 1, w: w, h: h, t: TK, z: 'f' });
```

**cubierta:** Single piece. Width = module width, depth = d parameter (typically 600mm with 20-30mm overhang). Zone = 'f'. No TK — cubierta is a separate material (postformado/cuarzo/granito), so set `t: 0` and a special flag `isCubierta: true` for pricing.
```javascript
} else if (moduleType === 'cubierta') {
    // AUDIT: Cubierta — priced per m2, not by sheet. w=length, h=depth
    pieces.push({ n: 'Cubierta', qty: 1, w: w, h: d, t: 0, z: 'f', isCubierta: true });
```

5. Add assignHardware() blocks for the 4 extras (all return empty arrays — extras have no hardware):
```javascript
} else if (moduleType === 'zoclo' || moduleType === 'vistaLateral' || moduleType === 'panelRelleno' || moduleType === 'cubierta') {
    // Extras: no hardware
```

6. In calc(), add cubierta m2 pricing logic. After the existing piece cost calculation, check if any piece has `isCubierta: true`. For those pieces, override the sheet-based cost with m2-based pricing:
- Calculate area: `(piece.w * piece.h) / 1000000` (mm2 to m2)
- Apply merma: multiply by CONFIG.pricing.mermaFactor (1.20)
- Get price per m2 from CONFIG.pricing.cubiertaPrices[m.cubiertaType || 'postformado']
- Add this to a new `cubiertaCost` accumulator in the calc result
- Include cubiertaCost in the extras bucket (extraCost)

7. In step2(), add cubierta type selector for cubierta modules:
```javascript
if (m.type === 'cubierta') {
    var cubT = m.cubiertaType || 'postformado';
    h += '<div class="module-row"><span>Tipo:</span><div style="display:flex;gap:6px;flex-wrap:wrap">';
    [['postformado', 'Postformado'], ['cuarzo', 'Cuarzo'], ['granito', 'Granito']].forEach(function(opt) {
        h += '<button class="opt-btn' + (cubT === opt[0] ? ' sel' : '') + '" onclick="APP.setModProp(\'' + m.id + '\',\'cubiertaType\',\'' + opt[0] + '\')">' + opt[1] + '</button>';
    });
    h += '</div></div>';
}
```

Use ES5 syntax only (var, no arrow functions, no template literals). Follow existing AUDIT comment pattern for all dimension constants.
  </action>
  <verify>
Search the file for `forType` — every MODS entry should have this field. Search for `zoclo`, `vistaLateral`, `panelRelleno`, `cubierta` in MODS, calculateParts(), and assignHardware(). Search for `cubiertaPrices` in CONFIG. Confirm no syntax errors by opening the HTML file in a browser (no JS console errors).
  </verify>
  <done>All MODS entries have forType field. 4 extras MODS entries exist with cat:'Extras'. calculateParts() returns pieces for all 4 extras types. cubierta pricing uses m2-based formula from CONFIG. step2() shows cubierta type selector.</done>
</task>

<task type="auto">
  <name>Task 2: Filter step2() module buttons by project type and group by category</name>
  <files>cotizador-template/cotizador-template.html</files>
  <action>
Replace the existing unfiltered `for (var k in MODS)` loop in step2() (around line 7151-7153) with filtered and grouped rendering:

1. Filter MODS by project type. Only show modules whose `forType` array includes `P.type`. If a module has no `forType` field (legacy/other), show it only when P.type is 'otro' or when no type is selected.

2. Group filtered modules by `cat` field. For cocina, this produces groups: "Bajos", "Alacenas", "Torres", "Extras". For closet and other types that don't have cat, use a single group (no header).

3. Render each group with a category header (small, gray label text) followed by the module buttons:

```javascript
// Filter modules by project type
var filteredKeys = [];
for (var k in MODS) {
    var modDef = MODS[k];
    if (modDef.forType) {
        if (modDef.forType.indexOf(P.type) !== -1) filteredKeys.push(k);
    } else {
        // Legacy modules without forType: show for 'otro' or unset type
        if (!P.type || P.type === 'otro') filteredKeys.push(k);
    }
}

// Group by cat
var groups = {};
var groupOrder = [];
filteredKeys.forEach(function(k) {
    var c = MODS[k].cat || '';
    if (!groups[c]) { groups[c] = []; groupOrder.push(c); }
    groups[c].push(k);
});

// Render grouped buttons
groupOrder.forEach(function(gName) {
    if (gName) {
        h += '<div style="width:100%;font-size:11px;color:#999;text-transform:uppercase;letter-spacing:1px;margin:8px 0 4px;padding-top:6px;border-top:1px solid #333">' + gName + '</div>';
    }
    groups[gName].forEach(function(k) {
        h += '<button class="add-btn" onclick="APP.addMod(\'' + k + '\')">' + svg('plus') + MODS[k].n + '</button>';
    });
});
```

4. When P.type is 'cocina', also add `isDualType` function already returns true for 'cocina' — verify no changes needed there.

5. In step2(), when adding a zoclo/vistaLateral/panelRelleno/cubierta module, these extras should skip the door/quoteMode toggles. Add these types to the existing puerta-type guard:
```javascript
if (m.type !== 'puerta' && m.type !== 'zoclo' && m.type !== 'vistaLateral' && m.type !== 'panelRelleno' && m.type !== 'cubierta') {
```

6. For the calc() door block, add the 4 extras types to the skip guard (they have no doors):
```javascript
if (m.type === 'cajonera' || m.type === 'hornoBase' || m.type === 'torreHornos' || m.type === 'zoclo' || m.type === 'vistaLateral' || m.type === 'panelRelleno' || m.type === 'cubierta') {
```

Use ES5 syntax only.
  </action>
  <verify>
Open the HTML in a browser. Select "Cocina" as project type. Verify that Step 2 shows ONLY cocina modules grouped under "Bajos", "Alacenas", "Torres", "Extras" headers. Select "Closet" — verify only closet modules appear. Select "Otro" — verify legacy/ungrouped modules appear. Add a cubierta module — verify no door/quoteMode toggles appear. Verify no JS console errors.
  </verify>
  <done>Step 2 module picker filters by project type. Cocina shows 4 category groups (Bajos, Alacenas, Torres, Extras). Extras modules skip door/quoteMode UI. Other project types show their own filtered modules.</done>
</task>

</tasks>

<verification>
1. Open HTML in browser, no JS console errors
2. Select Cocina → only cocina modules visible, grouped by category
3. Select Closet → only closet modules visible
4. Add zoclo, vista lateral, panel relleno, cubierta → pieces appear in despiece
5. Cubierta shows postformado/cuarzo/granito selector → pricing uses m2
6. Extras modules have no door/quoteMode toggles
</verification>

<success_criteria>
- All 4 extras module types (zoclo, vistaLateral, panelRelleno, cubierta) exist in MODS with calculateParts() blocks
- step2() filters modules by P.type using forType field
- Cocina modules grouped by cat: Bajos, Alacenas, Torres, Extras
- Cubierta pricing is m2-based with type selector (postformado/cuarzo/granito)
</success_criteria>

<output>
After completion, create `.planning/phases/04-cocina-extras-ui-output/04-01-SUMMARY.md`
</output>
